/* GML parser
 * coded by Ketmar // Invisible Vector <ketmar@ketmar.no-ip.org>
 * Understanding is not required. Only obedience.
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 */
module gaem.parser.tokens;


enum Keyword {
  NoKW,
  All,
  And,
  Break,
  Case,
  Continue,
  Default,
  Div,
  Do,
  Else,
  Exit,
  False,
  For,
  Function,
  Global,
  Globalvar,
  If,
  Mod,
  Noone,
  Not,
  Or,
  Other,
  Pi,
  Repeat,
  Return,
  Self,
  Switch,
  True,
  Until,
  Var,
  While,
  With,
  Xor,
  Add,
  Sub,
  Mul,
  RDiv,
  BitAnd,
  BitOr,
  BitXor,
  BitNeg,
  LogAnd,
  LogOr,
  LogXor,
  LogNot,
  Less,
  Great,
  LessEqu,
  GreatEqu,
  Equ,
  NotEqu,
  Ass,
  AssAdd,
  AssSub,
  AssMul,
  AssDiv,
  AssBitAnd,
  AssBitOr,
  AssBitXor,
  AssLShift,
  AssRShift,
  Semi,
  Colon,
  Comma,
  Dot,
  LCurly,
  RCurly,
  LParen,
  RParen,
  LBracket,
  RBracket,
  LShift,
  RShift,
  PlusPlus,
  MinusMinus,
}


__gshared immutable Keyword[string] keywords;
__gshared immutable string[int] keywordstx;


shared static this () {
  keywords = [
    "all": Keyword.All,
    "and": Keyword.And,
    "break": Keyword.Break,
    "case": Keyword.Case,
    "continue": Keyword.Continue,
    "default": Keyword.Default,
    "div": Keyword.Div,
    "do": Keyword.Do,
    "else": Keyword.Else,
    "exit": Keyword.Exit,
    "false": Keyword.False,
    "for": Keyword.For,
    "function": Keyword.Function,
    "global": Keyword.Global,
    "globalvar": Keyword.Globalvar,
    "if": Keyword.If,
    "mod": Keyword.Mod,
    "noone": Keyword.Noone,
    "not": Keyword.Not,
    "or": Keyword.Or,
    "other": Keyword.Other,
    "pi": Keyword.Pi,
    "repeat": Keyword.Repeat,
    "return": Keyword.Return,
    "self": Keyword.Self,
    "switch": Keyword.Switch,
    "true": Keyword.True,
    "until": Keyword.Until,
    "var": Keyword.Var,
    "while": Keyword.While,
    "with": Keyword.With,
    "xor": Keyword.Xor,
    "+": Keyword.Add,
    "-": Keyword.Sub,
    "*": Keyword.Mul,
    "/": Keyword.RDiv,
    "&": Keyword.BitAnd,
    "|": Keyword.BitOr,
    "^": Keyword.BitXor,
    "~": Keyword.BitNeg,
    "&&": Keyword.LogAnd,
    "||": Keyword.LogOr,
    "^^": Keyword.LogXor,
    "!": Keyword.LogNot,
    "<": Keyword.Less,
    ">": Keyword.Great,
    "<=": Keyword.LessEqu,
    ">=": Keyword.GreatEqu,
    "==": Keyword.Equ,
    "!=": Keyword.NotEqu,
    "=": Keyword.Ass,
    "+=": Keyword.AssAdd,
    "-=": Keyword.AssSub,
    "*=": Keyword.AssMul,
    "/=": Keyword.AssDiv,
    "&=": Keyword.AssBitAnd,
    "|=": Keyword.AssBitOr,
    "^=": Keyword.AssBitXor,
    "<<=": Keyword.AssLShift,
    ">>=": Keyword.AssRShift,
    ";": Keyword.Semi,
    ":": Keyword.Colon,
    ",": Keyword.Comma,
    ".": Keyword.Dot,
    "{": Keyword.LCurly,
    "}": Keyword.RCurly,
    "(": Keyword.LParen,
    ")": Keyword.RParen,
    "[": Keyword.LBracket,
    "]": Keyword.RBracket,
    "<<": Keyword.LShift,
    ">>": Keyword.RShift,
    "++": Keyword.PlusPlus,
    "--": Keyword.MinusMinus,
  ];
  keywordstx = [
    Keyword.All: "all",
    Keyword.And: "and",
    Keyword.Break: "break",
    Keyword.Case: "case",
    Keyword.Continue: "continue",
    Keyword.Default: "default",
    Keyword.Div: "div",
    Keyword.Do: "do",
    Keyword.Else: "else",
    Keyword.Exit: "exit",
    Keyword.False: "false",
    Keyword.For: "for",
    Keyword.Function: "function",
    Keyword.Global: "global",
    Keyword.Globalvar: "globalvar",
    Keyword.If: "if",
    Keyword.Mod: "mod",
    Keyword.Noone: "noone",
    Keyword.Not: "not",
    Keyword.Or: "or",
    Keyword.Other: "other",
    Keyword.Pi: "pi",
    Keyword.Repeat: "repeat",
    Keyword.Return: "return",
    Keyword.Self: "self",
    Keyword.Switch: "switch",
    Keyword.True: "true",
    Keyword.Until: "until",
    Keyword.Var: "var",
    Keyword.While: "while",
    Keyword.With: "with",
    Keyword.Xor: "xor",
    Keyword.Add: "+",
    Keyword.Sub: "-",
    Keyword.Mul: "*",
    Keyword.RDiv: "/",
    Keyword.BitAnd: "&",
    Keyword.BitOr: "|",
    Keyword.BitXor: "^",
    Keyword.BitNeg: "~",
    Keyword.LogAnd: "&&",
    Keyword.LogOr: "||",
    Keyword.LogXor: "^^",
    Keyword.LogNot: "!",
    Keyword.Less: "<",
    Keyword.Great: ">",
    Keyword.LessEqu: "<=",
    Keyword.GreatEqu: ">=",
    Keyword.Equ: "==",
    Keyword.NotEqu: "!=",
    Keyword.Ass: "=",
    Keyword.AssAdd: "+=",
    Keyword.AssSub: "-=",
    Keyword.AssMul: "*=",
    Keyword.AssDiv: "/=",
    Keyword.AssBitAnd: "&=",
    Keyword.AssBitOr: "|=",
    Keyword.AssBitXor: "^=",
    Keyword.AssLShift: "<<=",
    Keyword.AssRShift: ">>=",
    Keyword.Semi: ";",
    Keyword.Colon: ":",
    Keyword.Comma: ",",
    Keyword.Dot: ".",
    Keyword.LCurly: "{",
    Keyword.RCurly: "}",
    Keyword.LParen: "(",
    Keyword.RParen: ")",
    Keyword.LBracket: "[",
    Keyword.RBracket: "]",
    Keyword.LShift: "<<",
    Keyword.RShift: ">>",
    Keyword.PlusPlus: "++",
    Keyword.MinusMinus: "--",
  ];
}


static string keywordtext (uint id) {
  if (auto kw = id in keywordstx) return *kw;
  return "<unknown>";
}
