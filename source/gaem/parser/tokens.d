/* GML parser
 * coded by Ketmar // Invisible Vector <ketmar@ketmar.no-ip.org>
 * Understanding is not required. Only obedience.
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, version 3 of the License ONLY.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 */
module gaem.parser.tokens;


enum Keyword{
	NoKW,
	All,
	And,
	Break,
	Case,
	Continue,
	Default,
	Div,
	Do,
	Else,
	Exit,
	False,
	For,
	Function,
	Global,
	Globalvar,
	If,
	Mod,
	Noone,
	Not,
	Or,
	Other,
	Pi,
	Repeat,
	Return,
	Self,
	Switch,
	True,
	Until,
	Var,
	While,
	With,
	Xor,
	Add,
	Sub,
	Mul,
	RDiv,
	BitAnd,
	BitOr,
	BitXor,
	BitNeg,
	LogAnd,
	LogOr,
	LogXor,
	LogNot,
	Less,
	Great,
	LessEqu,
	GreatEqu,
	Equ,
	NotEqu,
	Ass,
	AssAdd,
	AssSub,
	AssMul,
	AssDiv,
	AssBitAnd,
	AssBitOr,
	AssBitXor,
	AssLShift,
	AssRShift,
	Semi,
	Colon,
	Comma,
	Dot,
	LCurly,
	RCurly,
	LParen,
	RParen,
	LBracket,
	RBracket,
	LShift,
	RShift,
	PlusPlus,
	MinusMinus,
}


__gshared immutable Keyword[string] keywords;
__gshared immutable string[int] keywordstx;


shared static this(){
	keywords = [
		"all": Keyword.All,
		"and": Keyword.And,
		"break": Keyword.Break,
		"case": Keyword.Case,
		"continue": Keyword.Continue,
		"default": Keyword.Default,
		"div": Keyword.Div,
		"do": Keyword.Do,
		"else": Keyword.Else,
		"exit": Keyword.Exit,
		"false": Keyword.False,
		"for": Keyword.For,
		"function": Keyword.Function,
		"global": Keyword.Global,
		"globalvar": Keyword.Globalvar,
		"if": Keyword.If,
		"mod": Keyword.Mod,
		"noone": Keyword.Noone,
		"not": Keyword.Not,
		"or": Keyword.Or,
		"other": Keyword.Other,
		"pi": Keyword.Pi,
		"repeat": Keyword.Repeat,
		"return": Keyword.Return,
		"self": Keyword.Self,
		"switch": Keyword.Switch,
		"true": Keyword.True,
		"until": Keyword.Until,
		"var": Keyword.Var,
		"while": Keyword.While,
		"with": Keyword.With,
		"xor": Keyword.Xor,
		"+": Keyword.Add,
		"-": Keyword.Sub,
		"*": Keyword.Mul,
		"/": Keyword.RDiv,
		"&": Keyword.BitAnd,
		"|": Keyword.BitOr,
		"^": Keyword.BitXor,
		"~": Keyword.BitNeg,
		"&&": Keyword.LogAnd,
		"||": Keyword.LogOr,
		"^^": Keyword.LogXor,
		"!": Keyword.LogNot,
		"<": Keyword.Less,
		">": Keyword.Great,
		"<=": Keyword.LessEqu,
		">=": Keyword.GreatEqu,
		"==": Keyword.Equ,
		"!=": Keyword.NotEqu,
		"=": Keyword.Ass,
		"+=": Keyword.AssAdd,
		"-=": Keyword.AssSub,
		"*=": Keyword.AssMul,
		"/=": Keyword.AssDiv,
		"&=": Keyword.AssBitAnd,
		"|=": Keyword.AssBitOr,
		"^=": Keyword.AssBitXor,
		"<<=": Keyword.AssLShift,
		">>=": Keyword.AssRShift,
		";": Keyword.Semi,
		":": Keyword.Colon,
		",": Keyword.Comma,
		".": Keyword.Dot,
		"{": Keyword.LCurly,
		"}": Keyword.RCurly,
		"(": Keyword.LParen,
		")": Keyword.RParen,
		"[": Keyword.LBracket,
		"]": Keyword.RBracket,
		"<<": Keyword.LShift,
		">>": Keyword.RShift,
		"++": Keyword.PlusPlus,
		"--": Keyword.MinusMinus,
	];
	keywordstx = [
		Keyword.All: "all",
		Keyword.And: "and",
		Keyword.Break: "break",
		Keyword.Case: "case",
		Keyword.Continue: "continue",
		Keyword.Default: "default",
		Keyword.Div: "div",
		Keyword.Do: "do",
		Keyword.Else: "else",
		Keyword.Exit: "exit",
		Keyword.False: "false",
		Keyword.For: "for",
		Keyword.Function: "function",
		Keyword.Global: "global",
		Keyword.Globalvar: "globalvar",
		Keyword.If: "if",
		Keyword.Mod: "mod",
		Keyword.Noone: "noone",
		Keyword.Not: "not",
		Keyword.Or: "or",
		Keyword.Other: "other",
		Keyword.Pi: "pi",
		Keyword.Repeat: "repeat",
		Keyword.Return: "return",
		Keyword.Self: "self",
		Keyword.Switch: "switch",
		Keyword.True: "true",
		Keyword.Until: "until",
		Keyword.Var: "var",
		Keyword.While: "while",
		Keyword.With: "with",
		Keyword.Xor: "xor",
		Keyword.Add: "+",
		Keyword.Sub: "-",
		Keyword.Mul: "*",
		Keyword.RDiv: "/",
		Keyword.BitAnd: "&",
		Keyword.BitOr: "|",
		Keyword.BitXor: "^",
		Keyword.BitNeg: "~",
		Keyword.LogAnd: "&&",
		Keyword.LogOr: "||",
		Keyword.LogXor: "^^",
		Keyword.LogNot: "!",
		Keyword.Less: "<",
		Keyword.Great: ">",
		Keyword.LessEqu: "<=",
		Keyword.GreatEqu: ">=",
		Keyword.Equ: "==",
		Keyword.NotEqu: "!=",
		Keyword.Ass: "=",
		Keyword.AssAdd: "+=",
		Keyword.AssSub: "-=",
		Keyword.AssMul: "*=",
		Keyword.AssDiv: "/=",
		Keyword.AssBitAnd: "&=",
		Keyword.AssBitOr: "|=",
		Keyword.AssBitXor: "^=",
		Keyword.AssLShift: "<<=",
		Keyword.AssRShift: ">>=",
		Keyword.Semi: ";",
		Keyword.Colon: ":",
		Keyword.Comma: ",",
		Keyword.Dot: ".",
		Keyword.LCurly: "{",
		Keyword.RCurly: "}",
		Keyword.LParen: "(",
		Keyword.RParen: ")",
		Keyword.LBracket: "[",
		Keyword.RBracket: "]",
		Keyword.LShift: "<<",
		Keyword.RShift: ">>",
		Keyword.PlusPlus: "++",
		Keyword.MinusMinus: "--",
	];
}


static string keywordtext(uint id){
	if(auto kw = id in keywordstx) return *kw;
	return "<unknown>";
}
